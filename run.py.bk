# A simple run.py for the demo

import time
import sys
from leds import ColumnedLEDStrip
from music import calculate_levels, read_musicfile_in_chunks, calculate_column_frequency
from shairplay import initialize_shairplay, shutdown_shairplay, RaopCallbacks

if len(sys.argv) > 1:
    path = sys.argv[1]
else:
    path = 'sample.mp3'

columns = 12
gap_leds = 0
total_leds = 100
skip_leds = 4

led = ColumnedLEDStrip(leds=total_leds, columns=columns, gap_leds=gap_leds, skip_leds=skip_leds)
led.all_off()
time.sleep(0.1)

frequency_limits =  calculate_column_frequency(100, 20000, columns)
print frequency_limits


# led.display_data([16] * 12)
# data = [16] * columns
# while True:
#     led.display_data(data)
#     time.sleep(0.01)

#for chunk, sample_rate in read_musicfile_in_chunks(path, play_audio=False):
#     data = calculate_levels(chunk, sample_rate, frequency_limits)
#     #data = [16] * columns
#     led.display_data(data)
# while True:
#     data = [16] * columns
#     led.display_data(data)


# import sys
# sys.exit(1)

class SampleCallbacks(RaopCallbacks):
    def audio_init(self, bits, channels, samplerate):
        print "Initializing", bits, channels, samplerate
        self.bits = bits
        self.channels = channels
        self.samplerate = samplerate

        output = aa.PCM(aa.PCM_PLAYBACK, aa.PCM_NORMAL)
        output.setchannels(channels)
        output.setrate(samplerate)
        output.setformat(aa.PCM_FORMAT_S16_LE)

        self.output = output

        # self.led = ColumnedLEDStrip(
        #     leds=total_leds,
        #     columns=columns,
        #     gap_leds=gap_leds,
        #     skip_leds=skip_leds
        # )
        self.led = led
        min_frequency = 300
        max_frequency = samplerate / 20 * 10  # Abusing integer division
        self.frequency_limits = calculate_column_frequency(
            min_frequency, max_frequency, columns
        )
        self.buffer = ''

    def audio_process(self, session, buffer):
        from IPython.core.debugger import Tracer; Tracer()()
        if len(buffer) > 0:
            self.output.setperiodsize(len(buffer))
            self.output.write(buffer)

        # data = [16] * columns
        # assert columns == 12
        # while True:
        #     self.led.display_data(data)
        #     time.sleep(0.01)

        # led.display_data(data)
        # time.sleep(2)
        # print "Processing", + len(buffer), "bytes of audio"
        # if len(self.buffer) < 2048:
        #     self.buffer += buffer
        # else:
        #     data = calculate_levels(
        #         self.buffer, self.samplerate, self.frequency_limits, self.channels, self.bits
        #     )
        #     print data, 'CALCULATED DATA'
        #     data = [10000] * columns
        #     self.led.display_data(data)
    def audio_destroy(self, session):
        print "Destroying"
    def audio_set_volume(self, session, volume):
        print "Set volume to", volume
    def audio_set_metadata(self, session, metadata):
        print "Got", len(metadata),  "bytes of metadata"
    def audio_set_coverart(self, session, coverart):
        print "Got", len(coverart), "bytes of coverart"


path = "/home/pi/spectrum-analyzer/shairplay/src/lib/.libs/"
initialize_shairplay(path, SampleCallbacks)
#shutdown_shairplay()

# cb = SampleCallbacks()
# cb.led = led
# cb.audio_process(None, None)

while True:
    try:
        pass
    except KeyboardInterrupt:
        shutdown_shairplay()
        break
